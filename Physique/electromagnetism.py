{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c7a89222",
   "metadata": {},
   "outputs": [],
   "source": [
    "__all__ = [\n",
    "    \"Charge\",\n",
    "    \"ElectricField\",\n",
    "    \"Current\",\n",
    "    \"CurrentMagneticField\",\n",
    "    \"BarMagnet\",\n",
    "    \"BarMagneticField\",\n",
    "]\n",
    "\n",
    "from typing import Sequence\n",
    "from manim import *\n",
    "\n",
    "\n",
    "class Charge(VGroup):\n",
    "    def __init__(self, magnitude=1, point=ORIGIN, add_glow=True, **kwargs):\n",
    "        VGroup.__init__(self, **kwargs)\n",
    "        self.magnitude = magnitude\n",
    "        self.point = point\n",
    "        self.radius = (abs(magnitude) * 0.4 if abs(magnitude) < 2 else 0.8) * 0.3\n",
    "\n",
    "        if magnitude > 0:\n",
    "            label = VGroup(\n",
    "                Rectangle(width=0.32 * 1.1, height=0.006 * 1.1).set_z_index(1),\n",
    "                Rectangle(width=0.006 * 1.1, height=0.32 * 1.1).set_z_index(1),\n",
    "            )\n",
    "            color = RED\n",
    "            layer_colors = [RED_D, RED_A]\n",
    "            layer_radius = 4\n",
    "        else:\n",
    "            label = Rectangle(width=0.27, height=0.003)\n",
    "            color = BLUE\n",
    "            layer_colors = [\"#3399FF\", \"#66B2FF\"]\n",
    "            layer_radius = 2\n",
    "\n",
    "        if add_glow:  # use many arcs to simulate glowing\n",
    "            layer_num = 80\n",
    "            color_list = color_gradient(layer_colors, layer_num)\n",
    "            opacity_func = lambda t: 1500 * (1 - abs(t - 0.009) ** 0.0001)\n",
    "            rate_func = lambda t: t ** 2\n",
    "\n",
    "            for i in range(layer_num):\n",
    "                self.add(\n",
    "                    Arc(\n",
    "                        radius=layer_radius * rate_func((0.5 + i) / layer_num),\n",
    "                        angle=TAU,\n",
    "                        color=color_list[i],\n",
    "                        stroke_width=101\n",
    "                        * (rate_func((i + 1) / layer_num) - rate_func(i / layer_num))\n",
    "                        * layer_radius,\n",
    "                        stroke_opacity=opacity_func(rate_func(i / layer_num)),\n",
    "                    ).shift(point)\n",
    "                )\n",
    "\n",
    "        self.add(Dot(point=self.point, radius=self.radius, color=color))\n",
    "        self.add(label.scale(self.radius / 0.3).shift(point))\n",
    "        for mob in self:\n",
    "            mob.set_z_index(1)\n",
    "\n",
    "\n",
    "class ElectricField(ArrowVectorField):\n",
    "    def __init__(self, *charges: Charge, **kwargs):\n",
    "        self.charges = charges\n",
    "        super().__init__(\n",
    "            lambda p: self.field_func(p),\n",
    "            **kwargs\n",
    "        )\n",
    "\n",
    "    def field_func(self, p):\n",
    "        direction = np.zeros(3)\n",
    "        pos = []\n",
    "        for charge in self.charges:\n",
    "            p0, mag = charge.get_center(), charge.magnitude\n",
    "            pos.append(p0)\n",
    "            x, y, z = p - p0\n",
    "            dist = (x ** 2 + y ** 2) ** 1.5\n",
    "            if any((p - p0) ** 2 > 0.05):\n",
    "                direction += mag * np.array([x / dist, y / dist, 0])\n",
    "            else:\n",
    "                direction += np.zeros(3)\n",
    "        for p0 in pos:\n",
    "            if all((p - p0) ** 2 <= 0.05):\n",
    "                direction = np.zeros(3)\n",
    "        return direction\n",
    "\n",
    "    def get_force_on_charge(self, charge):\n",
    "        p = charge.get_center()\n",
    "        direction = np.zeros(3)\n",
    "        for other_charge in self.charges:\n",
    "            if other_charge == charge:\n",
    "                continue\n",
    "            p0, mag = other_charge.get_center(), other_charge.magnitude\n",
    "            x, y, z = p - p0\n",
    "            dist = (x ** 2 + y ** 2) ** 1.5\n",
    "            if (x ** 2) > 0.01 or (y ** 2) > 0.01:\n",
    "                direction += mag * np.array([x / dist, y / dist, 0])\n",
    "            else:\n",
    "                direction += np.zeros(3)\n",
    "        length = (direction[0] ** 2 + direction[1] ** 2) ** 0.5\n",
    "        vec_start = (\n",
    "            Vector(direction / length * charge.radius).shift(charge.point).get_end()\n",
    "        )\n",
    "        return Vector(direction).shift(vec_start)\n",
    "\n",
    "\n",
    "class Current(VGroup):\n",
    "    def __init__(\n",
    "        self, point: Sequence[float] = ORIGIN, magnitude=1, direction=OUT, **kwargs\n",
    "    ):\n",
    "        if np.all(direction == OUT) or np.all(direction == IN):\n",
    "            self.direction = direction\n",
    "        else:\n",
    "            raise ValueError(\"only IN and OUT are supported.\")\n",
    "        self.magnitude = magnitude\n",
    "        if np.all(direction == IN):\n",
    "            label = VGroup(\n",
    "                Line(ORIGIN, UR).move_to(ORIGIN),\n",
    "                Line(ORIGIN, UL).move_to(ORIGIN),\n",
    "            )\n",
    "            self.magnitude *= -1\n",
    "        else:\n",
    "            label = Dot(radius=0.2)\n",
    "        super().__init__(**kwargs)\n",
    "        self.add(Circle(color=WHITE), label).scale(0.2).shift(point)\n",
    "\n",
    "\n",
    "class CurrentMagneticField(ArrowVectorField):\n",
    "    def __init__(self, *currents: Current, **kwargs):\n",
    "        super().__init__(lambda p: self.field_func(p, *currents), **kwargs)\n",
    "\n",
    "    def field_func(self, p, *currents):\n",
    "        direction = np.zeros(3)\n",
    "        pos = []\n",
    "        for current in currents:\n",
    "            x, y, z = p\n",
    "            x0, y0, z0 = point = current.get_center()\n",
    "            mag = current.magnitude\n",
    "            pos.append(point)\n",
    "            if all((p - point) ** 2 > 0.01):\n",
    "                dist = np.linalg.norm(p - point)\n",
    "                direction += mag * np.array([-(y - y0), (x - x0), 0]) / dist ** 3\n",
    "            else:\n",
    "                direction += np.zeros(3)\n",
    "        for p0 in pos:\n",
    "            if all((p - p0) ** 2 <= 0.01):\n",
    "                direction = np.zeros(3)\n",
    "        return direction\n",
    "\n",
    "\n",
    "class BarMagnet(VGroup):\n",
    "    def __init__(\n",
    "        self,\n",
    "        north: Sequence[float] = UP,\n",
    "        south: Sequence[float] = DOWN,\n",
    "        height: float = 2,\n",
    "        width: float = 1,\n",
    "        **kwargs\n",
    "    ):\n",
    "        self.length = np.linalg.norm(north - south)\n",
    "        # self.width = width\n",
    "        super().__init__(**kwargs)\n",
    "        if width > height:\n",
    "            raise ValueError(\"Bar magnet must be taller than it's width\")\n",
    "        self.bar = VGroup(\n",
    "            Rectangle(\n",
    "                height=height / 2, width=width, fill_opacity=1, color=RED\n",
    "            ).next_to(ORIGIN, UP, 0),\n",
    "            Rectangle(\n",
    "                height=height / 2, width=width, fill_opacity=1, color=BLUE\n",
    "            ).next_to(ORIGIN, DOWN, 0),\n",
    "        )\n",
    "        self.north_label = Tex(\"N\").shift(UP * (self.length / 2 - 0.5))\n",
    "        self.south_label = Tex(\"S\").shift(UP * -(self.length / 2 - 0.5))\n",
    "        self.add(self.bar, self.north_label, self.south_label)\n",
    "        self.rotate(-PI / 2 + angle_of_vector(self.get_south_to_north()))\n",
    "\n",
    "    def get_south_to_north(self):\n",
    "        return Vector(\n",
    "            self.north_label.get_center() - self.south_label.get_center()\n",
    "        ).get_vector()\n",
    "\n",
    "\n",
    "class BarMagneticField(CurrentMagneticField):\n",
    "    def __init__(self, *bars: BarMagnet, **kwargs):\n",
    "        currents = []\n",
    "        for bar in bars:\n",
    "            width = np.linalg.norm(\n",
    "                bar.bar[0].get_vertices()[1] - bar.bar[0].get_vertices()[0]\n",
    "            )\n",
    "            length = (\n",
    "                np.linalg.norm(\n",
    "                    bar.bar[0].get_vertices()[2] - bar.bar[0].get_vertices()[1]\n",
    "                )\n",
    "                * 2\n",
    "            )\n",
    "            currents_ = []\n",
    "            currents_ += [\n",
    "                Current(magnitude=-1).move_to(i)\n",
    "                for i in np.linspace(\n",
    "                    [width / 2, length / 2, 0],\n",
    "                    [width / 2, -length / 2, 0],\n",
    "                    10,\n",
    "                )\n",
    "            ]\n",
    "            currents_ += [\n",
    "                Current(magnitude=1).move_to(i)\n",
    "                for i in np.linspace(\n",
    "                    [-bar.width / 2, bar.length / 2, 0],\n",
    "                    [-bar.width / 2, -bar.length / 2, 0],\n",
    "                    10,\n",
    "                )\n",
    "            ]\n",
    "            VGroup(*currents_).rotate(\n",
    "                -PI / 2 + angle_of_vector(bar.get_south_to_north())\n",
    "            ).shift(bar.get_center())\n",
    "            currents += currents_\n",
    "\n",
    "        super().__init__(*currents, **kwargs)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
